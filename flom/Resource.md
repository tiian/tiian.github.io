# Resource
Here's a [very high level definition](https://en.wikipedia.org/wiki/Resource#Computer_resources) of the term:

> A computer resource is any physical or virtual component of limited availability within a computer or information management system.

FLoM provides only two operations:

* lock(resource)
* unlock(resource)

FLoM creates and destroy the resources **automatically**, when they are necessary.    
Some options allow you to change the default behavior, but basically you don't have to care about creation, initialization and clean-up of the resources.

FLoM resources are not mapped to system resources like files, sockets, etc... You define your own resources inside your own synchronization domain.

FLoM provides **different types** of resources that allows you to implement different use cases without developing & testing your own logic. FLoM tries to give you the highest abstraction level.

FLoM **infers** the type of a resource from **its name**: there's a naming convention that you must use.

FLoM implements the same [Lock Modes](https://en.wikipedia.org/wiki/Distributed_lock_manager#Lock_modes) proposed by OpenVMS DLM (Distributed Lock Manager).

The term **locker** is used to express the concept of *a process that wants to get a lock*.

## Resource types
Here's the complete list:

* **simple**
* **numeric**
* **set**
* **hierarchical**
* **sequence**
* **timestamp**

[FLoM by examples](FLoM_by_examples/FLoM_by_examples.md) provides a lot of information related the usage of every type of resource.    
Below there's a brief summary to get oriented and to figure out the features at a glance.

## Simple
It's simple, it's like a semaphore, it's the cornerstone of process synchronization.
#### Syntax (regular expression):
~~~
([[:alpha:]][[:alpha:][:digit:]]*)
~~~
#### Examples:
~~~
foo
bar
foo123bar
fOoBaR
~~~
#### Lock modes:
All: Null, Concurrent Read, Concurrent Write, Protected Read, Protected Write, **Exclusive** (default).

## Numeric
It allows to model a synchronization scenario with *producers* and *consumers* typical of [Petri Net](https://en.wikipedia.org/wiki/Petri_net) modeling.   
A *producer* produces 1 or more units, a *consumer* consumes 1 or more units
#### Syntax (regular expression):
~~~
([[:alpha:]][[:alpha:][:digit:]]*)\\[([[:digit:]]+)\\]
~~~
#### Examples:
~~~
foo[4]
bar[34]
foo123bar[99]
fOoBaR[6]
~~~
#### Lock modes:
Exclusive only, locked quantity can be specified (default 1).

## Set
A predefined set of resources is available, the resources inside the set are distinguishable: every locker get the first available one (using a round robin algorithm).
#### Syntax (regular expression):
~~~
([[:alpha:]][[:alpha:][:digit:]]*)(\\.[[:alpha:]][[:alpha:][:digit:]]*)+
~~~
#### Examples:
~~~
foo.bar
red.green.blue
Apple.Pear.Strawberry.Cherry
~~~
#### Lock modes:
Exclusive only. The locked resource name, one in the set, is returned to the client that can use with some custom logic.

## Hierarchical
Useful to model a hierarchy, typical use case: filesystem.   
A lock applied to some level of the hierarchy, **propagates** to all the below levels.
#### Syntax (regular expression):
~~~
\\/[^\\/]+(\\/[^\\/]+)*
~~~
#### Examples:
~~~
/foo/bar
/red/green/blue
/Apple/Pear/Strawberry/Cherry
~~~
#### Lock modes:
All: Null, Concurrent Read, Concurrent Write, Protected Read, Protected Write, **Exclusive** (default).

## Sequence
Useful to synchronize processes and get a valid unique ID with **a single atomic operation**.   
*Sequence resources* can be **transactional** and **non transactional**: *transactional sequence resources* solves the annoying problem "*holes/gaps in numbers generated by a sequence*".
#### Syntax (regular expression):
~~~
_[sS]_([[:alpha:]][[:alpha:][:digit:]]*)\\[([[:digit:]]+)\\]
~~~
#### Examples:
~~~
_s_foo[1]
_S_bar[23]
~~~
#### Lock modes:
Exclusive only. The locked resource name, a unique sequence value (1, 2, 3, ...), is returned to the client that can use it with some custom logic.

## Timestamp
Useful to synchronize processes and get a valid unique timestamp with **a single atomic operation**.   
*Timestamp resources* solves the annoying problem of the "*how can I be sure that 2 processes get different timestamp in a concurrent distributed environment*".
#### Syntax (regular expression):
~~~
_[t]_([%#[:alpha:]][%#\\.\\:[:alpha:][:digit:]]*)\\[([[:digit:]]+)\\]
~~~
#### Examples:
~~~
_t_foo.%D.%T[4]
_t_bar:%S#fff[1]
~~~
#### Lock modes:
Exclusive only. The locked resource name, a unique timestamp (07/05/16.11:30:08, 07/05/16.11:30:09, 07/05/16.11:30:10, ...), is returned to the client that can use it with some custom logic.

